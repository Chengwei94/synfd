#' Generate sparse functional data
#' @param mu a function or scalar defining the mean function
#' @param X the centered stochastic process, a function that
#'          X(tObs,n) return n*len(tObs) matrix with n trajectories
#' @param n sample size
#' @param m sampling rate per trajectory. If \code{m} is an integer, than m_i is sampled from 1+Poison(m-1). If \code{m} is a vector of integers, m_i is sampled uniformly from this vector. If \code{m} is a function, it is then assumed to be a function f such that f(k) randomly generates k positive integers.
#' @param domain the domain
#' @param sig0 the std of measurement errors, if NULL, determined by snr
#' @param snr  the signal to noise ratio to determine sig0
#' @param delta the proportion of the domain to be observed. It must be a real number between 0 (exclusive) and 1 (inclusive). This argument is used to generate snippets. The onset time Oi is uniformly sampled from the interval [\code{domain[1]},\code{domain[2]-delta*(domain[2]-domain[1])}], and \eqn{t_{ij}}{tij} is uniformly sampled from [Oi,Oi+\code{delta*(domain[2]-domain[1])}].
#' @return a list of two members
#'   \item{t}{a list of \code{n} items, each being a nondecreasing vector that represents the time points of observations for a subject}
#'   \item{y}{a list of \code{n} items, each being a vector representing the observations corresponding to \code{t}}
#'
#'   and the following attributes
#'
#'      \item{sig0}
#'      \item{snr}{signal-to-nois ratio}
#'      \item{uncontaminated}{clean version of \code{y}}
#'      \item{domain}{the domain}
#'      \item{delta}
#'
#' @examples
#' # generate Gaussian samples with constant mean function 1
#' Y <- sparse.fd(mu=1, X=gaussian.process(), n=10, m=5)
#'
#' # generate samples froma a process defined via K-L representation
#' Y <- sparse.fd(mu=cos, X=kl.process(eigen.values=1/(2^(1:25)),eigen.functions='FOURIER',distribution='LAPLACE'),n=10, m=5)
#'
#' # generate samples with mi sample from 2,4,6
#' Y <- sparse.fd(mu=1, X=gaussian.process(cov=matern), n=10, m=c(2,4,6))
#' @export

sparse.fd <- function(mu, X, n, m,
                      sig0=NULL, snr=5, domain=c(0,1),
                      delta = 1)
{
    Lt <- list()
    Ly <- list()
    
    if(is.vector(m))
    {
        if(length(m) > 1)
            mi <- sample(m,size=n,replace=T)
        else
            mi <- 1 + rpois(n,m)
    }
    else if(is.function(m))
    {
        mi <- m(n)
    }
    
    L <- domain[2]-domain[1]
    O <- runif(n,min=domain[1],max=domain[2]-delta*L)
    Lt <- sapply(1:n,function(i){
        s <- O[i]
        sort(runif(mi[i], min=s, max=s+delta*L))
    })
    
    
    # now construct Ly based on Lt
    Ly0 <- lapply(Lt, function(tobs){
        
        if (is.function(mu)) mui <- mu(tobs)
        else if(length(mu)==1) mui <- rep(mu,length(tobs))
        else stop('mu must be a scalar or a function.')
        y0 <- mui + X(tobs,1)
        return(y0)
    })
    
    if(!is.null(snr))
    {
        if(!is.infinite(snr))
        {
            # roughly estimate the expectation of the L2 norm of X
            EX2 <- mean(apply(X(seq(domain[1],domain[2],length.out=100),100)^2,
                              1,sum)*L/100
            )
            sig0 <- sqrt(EX2/snr)
        }
        else sig0 <- 0
    }
    
    if(sig0 != 0)
    {
        Ly <- lapply(Ly0,function(y){
            y + rnorm(n=length(y),sd=sig0)
        })
    }
    else Ly <- Ly0
    
    R <- list(t=Lt,y=Ly)
    attr(R,'sig0') <- sig0
    attr(R,'snr') <- snr
    attr(R,'uncontaminated') <- Ly0
    attr(R,'domain') <- domain
    attr(R,'delta') <- delta
    attr(R,'class') <- 'sparse.fda'
    return(R)
}

#' plot sparse functional data
#' @param R the object generated by \code{gen.sparse.fda}
#' @param ... other parameters passed to \code{plot} and \code{lines}
#' @export
plot.sparse.fd <- function(R,...)
{
    plot(R$t[[1]],R$y[[1]],...)
    if(length(R$t) > 1)
    {
        for(i in 2:length(R$t))
        {
            lines(R$t[[1]],R$y[[1]],...)
        }
    }
}
